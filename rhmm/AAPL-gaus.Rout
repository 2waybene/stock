
R version 3.0.2 (2013-09-25) -- "Frisbee Sailing"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> library(quantmod)
Loading required package: Defaults
Loading required package: xts
Loading required package: zoo

Attaching package: ‘zoo’

The following objects are masked from ‘package:base’:

    as.Date, as.Date.numeric

Loading required package: TTR
Version 0.4-0 included new data defaults. See ?getSymbols.
> 
> require(devEMF)
Loading required package: devEMF
> #postscript('AAPL-gaus.eps')
> 
> getSymbols("AAPL")
    As of 0.4-0, ‘getSymbols’ uses env=parent.frame() and
 auto.assign=TRUE by default.

 This  behavior  will be  phased out in 0.5-0  when the call  will
 default to use auto.assign=FALSE. getOption("getSymbols.env") and 
 getOptions("getSymbols.auto.assign") are now checked for alternate defaults

 This message is shown once per session and may be disabled by setting 
 options("getSymbols.warning4.0"=FALSE). See ?getSymbol for more details
[1] "AAPL"
> chartSeries(AAPL, theme="white")
> AAPL_Subset <- window(AAPL, start = as.Date("2000-01-01"), end = as.Date("2013-03-01"))
> #AAPL_Train <- cbind(AAPL_Subset$AAPL.Close - AAPL_Subset$AAPL.Open, AAPL_Subset$AAPL.Volume)
> AAPL_Train <- cbind(AAPL_Subset$AAPL.Close - AAPL_Subset$AAPL.Open)
> #print(AAPL_Train)
> 
> testset <- window(AAPL, start = as.Date("2013-03-01"), end = as.Date("2014-03-01"))
> test <- cbind(testset$AAPL.Close - testset$AAPL.Open)
> 
> library(RHmm)
Loading required package: MASS
Loading required package: nlme
> # Baum-Welch Algorithm to find the model for the given observations
> #hm_model <- HMMFit(obs = AAPL_Train, nStates = 5)
> hm_model <- HMMFit(obs = AAPL_Train, nStates = 5, nMixt = 4, dis = "MIXTURE")
> 
> # Viterbi Algorithm to find the most probable state sequence
> VitPath <- viterbi (hm_model, AAPL_Train)
> 
> # scatter plot
> postscript('AAPL-gaus.eps')
> AAPL_Predict <- cbind(AAPL_Subset$AAPL.Close, VitPath$states)
> #print(AAPL_Subset)
> #print(AAPL_Subset[,4] - AAPL_Predict [,1])
> #print(AAPL_Predict)
> 
> # predict next stock value m = nMixt, n = nStates
> #sum(a[last(v),] * .colSums((matrix(unlist(a), nrow=4,ncol=5)) * (matrix(unlist(a), nrow=4,ncol=5)), m=4,n=5))
> # gaussian mixture HMM: nrow = nMixture, ncol = nStates
> print(hm_model$HMM$transMat[last(VitPath$states),])
[1]  1.434220e-05  9.743948e-16  7.230176e-03  9.927555e-01 1.937138e-301
> print(hm_model$HMM$distribution)

Model:
5 states HMM with mixture of 4 1-d gaussian distributions

Distribution parameters:
  State 1
              mean       var       prop
mixt.  1  9.041544  6.693938 0.07966831
mixt.  2  2.963883 15.935972 0.17548542
mixt.  3 -2.963579 10.546425 0.29812223
mixt.  4  1.794577  6.201068 0.44672404

  State 2
              mean       var       prop
mixt.  1 -6.590922 16.105232 0.09478065
mixt.  2 -8.293823 14.144658 0.14075151
mixt.  3 -6.047991  2.782205 0.18223533
mixt.  4  2.099725  3.601287 0.58223251

  State 3
              mean       var      prop
mixt.  1 -2.300361  2.413159 0.1550631
mixt.  2  8.219482 10.886770 0.1805717
mixt.  3 -2.582991  2.124076 0.2487266
mixt.  4 -2.464426  2.349859 0.4156386

  State 4
               mean        var      prop
mixt.  1 -9.6920667  97.298208 0.1686797
mixt.  2  0.5497074   8.833689 0.2248771
mixt.  3  5.1965718 124.514246 0.2821865
mixt.  4 -6.3250807  28.366578 0.3242567

  State 5
                mean        var       prop
mixt.  1 -4.54812305  0.5140463 0.02534192
mixt.  2 -3.25704858 11.6636749 0.05178770
mixt.  3  2.72887343  4.3410278 0.18170309
mixt.  4 -0.09900502  2.7322182 0.74116729

> print(hm_model$HMM$distribution$mean)
[[1]]
[1]  9.041544  2.963883 -2.963579  1.794577

[[2]]
[1] -6.590922 -8.293823 -6.047991  2.099725

[[3]]
[1] -2.300361  8.219482 -2.582991 -2.464426

[[4]]
[1] -9.6920667  0.5497074  5.1965718 -6.3250807

[[5]]
[1] -4.54812305 -3.25704858  2.72887343 -0.09900502

> #print(hm_model$HMM$distribution$mean[, seq(1, ncol(hm_model$HMM$distribution$mean), by = 2)])
> print(unlist(hm_model$HMM$distribution$mean))
 [1]  9.04154432  2.96388323 -2.96357855  1.79457700 -6.59092190 -8.29382335
 [7] -6.04799069  2.09972516 -2.30036094  8.21948222 -2.58299112 -2.46442559
[13] -9.69206672  0.54970739  5.19657177 -6.32508075 -4.54812305 -3.25704858
[19]  2.72887343 -0.09900502
> #print(unlist(hm_model$HMM$distribution$mean[1,]))
> #print(matrix(unlist(hm_model$HMM$distribution$mean[1,])))
> #print(matrix(unlist(hm_model$HMM$distribution$proportion[1,])))
> 
> # predict 
> #sum(hm_model$HMM$transMat[last(VitPath$states),] * .colSums((matrix(unlist(hm_model$HMM$distribution$mean[1,]), nrow=4,ncol=5)) * (matrix(unlist(hm_model$HMM$distribution$proportion[1,]), nrow=4,ncol=5)), m=4,n=5))
> change <- sum(hm_model$HMM$transMat[last(VitPath$states),] * .colSums((matrix(unlist(hm_model$HMM$distribution$mean), nrow=4,ncol=5)) * (matrix(unlist(hm_model$HMM$distribution$proportion), nrow=4,ncol=5)), m=4,n=5))
> print(change)
[1] -2.084485
> #print(tail(AAPL_Subset$AAPL.Close))
> head5 <- head(AAPL_Subset$AAPL.Close)
> print(head5)
           AAPL.Close
2007-01-03      83.80
2007-01-04      85.66
2007-01-05      85.05
2007-01-08      85.47
2007-01-09      92.57
2007-01-10      97.00
> pred <- head5 + change
> #pred <- (tail(AAPL_Subset$AAPL.Close) + change)
> print(pred)
           AAPL.Close
2007-01-03   81.71552
2007-01-04   83.57552
2007-01-05   82.96552
2007-01-08   83.38552
2007-01-09   90.48552
2007-01-10   94.91552
> 
> #actual <- head(testset$AAPL.Close)
> actual <- head(testset$AAPL.Open)
> print(actual)
           AAPL.Open
2013-03-01    438.00
2013-03-04    427.80
2013-03-05    421.48
2013-03-06    434.51
2013-03-07    424.50
2013-03-08    429.80
> 
> # MAPE = sum(|pred - actual|/|actual|)*100/n
> #MAPE <- pred$AAPL.Close - actual$AAPL.Close
> #MAPE <- abs((pred$AAPL.Close - actual$AAPL.Close)/actual$AAPL.Close)
> MAPE <- abs((pred$AAPL.Close - 420.05)/420.05) * 100
> print(MAPE)
           AAPL.Close
2007-01-03   80.54624
2007-01-04   80.10344
2007-01-05   80.24866
2007-01-08   80.14867
2007-01-09   78.45839
2007-01-10   77.40376
> 
> # single HMM
> #sum(hm_model$HMM$transMat[last(VitPath$states),] * .colSums((matrix(unlist(hm_model$HMM$distribution$mean), nrow=1,ncol=5)) * (matrix(unlist(hm_model$HMM$distribution$proportion), nrow=1,ncol=5)), m=1,n=5))
> 
> #chartSeries(testset, theme="white")
> #chartSeries(test, theme="white")
> 
> # Forward-backward 
> fb <- forwardBackward(hm_model, test, FALSE)
> #print(fb)
> #print(AAPL_Subset[,4] - AAPL_Predict [,1])
> 
> #layout(matrix(1:2, nrow=2))
> #layout(matrix(2:1, ncol=2))
> layout(1:2)
> print(matrix(2:1, ncol=2))
     [,1] [,2]
[1,]    2    1
> 
> # show the states with predicted closing value
> #chartSeries(pred)
> chartSeries(pred, TA = "addTA(pred - change, on = 1)")
> 
> #chartSeries(AAPL_Predict[,1], #theme="white.mono", 
> #chartSeries(AAPL_Predict[,1], layout = layout(matrix(2:1)), # 1, 2, byrow = TRUE), #respect = TRUE), #theme="white.mono", 
> #TA="addTA(AAPL_Predict[AAPL_Predict[,2]==1,1], legend = \"one day?\", on=1, col=5,pch=25);
> #addTA(AAPL_Predict[AAPL_Predict[,2]==2,1],on=1,type='p',col=6,pch=24);
> #addTA(AAPL_Predict[AAPL_Predict[,2]==3,1],on=1,type='p',col=7,pch=23);
> #addTA(AAPL_Predict[AAPL_Predict[,2]==4,1],on=1,type='p',col=8,pch=22);
> #addTA(AAPL_Predict[AAPL_Predict[,2]==5,1],on=1,type='p',col=10,pch=21)
> #")
> 
> #addTA(AAPL_Predict[AAPL_Predict[,2]==1,1],on=1,type="p",col=5,pch=25)
> #addTA(AAPL_Predict[AAPL_Predict[,2]==2,1],on=1,type="p",col=6,pch=24)
> #addTA(AAPL_Predict[AAPL_Predict[,2]==3,1],on=1,type="p",col=7,pch=23)
> #addTA(AAPL_Predict[AAPL_Predict[,2]==4,1],on=1,type="p",col=8,pch=22)
> #addTA(AAPL_Predict[AAPL_Predict[,2]==5,1],on=1,type="p",col=10,pch=21)
> 
> 
> proc.time()
   user  system elapsed 
  4.034   0.059   4.269 
