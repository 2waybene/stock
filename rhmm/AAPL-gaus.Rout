
R version 3.0.2 (2013-09-25) -- "Frisbee Sailing"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> library(quantmod)
Loading required package: Defaults
Loading required package: xts
Loading required package: zoo

Attaching package: ‘zoo’

The following objects are masked from ‘package:base’:

    as.Date, as.Date.numeric

Loading required package: TTR
Version 0.4-0 included new data defaults. See ?getSymbols.
> 
> require(devEMF)
Loading required package: devEMF
> #postscript('AAPL-gaus.eps')
> 
> getSymbols("AAPL")
    As of 0.4-0, ‘getSymbols’ uses env=parent.frame() and
 auto.assign=TRUE by default.

 This  behavior  will be  phased out in 0.5-0  when the call  will
 default to use auto.assign=FALSE. getOption("getSymbols.env") and 
 getOptions("getSymbols.auto.assign") are now checked for alternate defaults

 This message is shown once per session and may be disabled by setting 
 options("getSymbols.warning4.0"=FALSE). See ?getSymbol for more details
[1] "AAPL"
> chartSeries(AAPL, theme="white")
> AAPL_Subset <- window(AAPL, start = as.Date("2000-01-01"), end = as.Date("2013-03-01"))
> #AAPL_Train <- cbind(AAPL_Subset$AAPL.Close - AAPL_Subset$AAPL.Open, AAPL_Subset$AAPL.Volume)
> AAPL_Train <- cbind(AAPL_Subset$AAPL.Close - AAPL_Subset$AAPL.Open)
> #print(AAPL_Train)
> 
> testset <- window(AAPL, start = as.Date("2013-03-02"), end = as.Date("2014-03-01"))
> test <- cbind(testset$AAPL.Close - testset$AAPL.Open)
> 
> library(RHmm)
Loading required package: MASS
Loading required package: nlme
> # Baum-Welch Algorithm to find the model for the given observations
> #hm_model <- HMMFit(obs = AAPL_Train, nStates = 5)
> hm_model <- HMMFit(obs = AAPL_Train, nStates = 5, nMixt = 4, dis = "MIXTURE")
> 
> # Viterbi Algorithm to find the most probable state sequence
> VitPath <- viterbi (hm_model, AAPL_Train)
> 
> # scatter plot
> postscript('AAPL-gaus.eps')
> AAPL_Predict <- cbind(AAPL_Subset$AAPL.Close, VitPath$states)
> #print(AAPL_Subset)
> #print(AAPL_Subset[,4] - AAPL_Predict [,1])
> #print(AAPL_Predict)
> 
> # predict next stock value m = nMixt, n = nStates
> #sum(a[last(v),] * .colSums((matrix(unlist(a), nrow=4,ncol=5)) * (matrix(unlist(a), nrow=4,ncol=5)), m=4,n=5))
> # gaussian mixture HMM: nrow = nMixture, ncol = nStates
> print(hm_model$HMM$transMat[last(VitPath$states),])
[1]  8.778333e-01  1.221667e-01  6.659115e-53  4.600856e-58 1.434550e-151
> print(hm_model$HMM$distribution)

Model:
5 states HMM with mixture of 4 1-d gaussian distributions

Distribution parameters:
  State 1
              mean          var       prop
mixt.  1  1.660939   0.01036198 0.02034015
mixt.  2  4.316445  21.45755771 0.27906856
mixt.  3 -1.303234 128.38271515 0.27958447
mixt.  4 -1.831079  14.31016140 0.42100682

  State 2
               mean         var      prop
mixt.  1   2.806775 0.003667137 0.1302546
mixt.  2  -4.777410 0.129084765 0.1840795
mixt.  3 -11.513074 0.198372801 0.2708536
mixt.  4  -8.218117 0.453215621 0.4148122

  State 3
              mean      var       prop
mixt.  1  2.361224 4.485665 0.06222790
mixt.  2 -5.378609 7.466536 0.08586168
mixt.  3  1.073019 1.450923 0.36324857
mixt.  4  2.945220 4.403002 0.48866185

  State 4
                mean        var       prop
mixt.  1 -0.92275326 2.95829115 0.06399896
mixt.  2 -0.01946494 0.03537303 0.10608859
mixt.  3 -2.17184476 1.11370277 0.31443916
mixt.  4 -3.00404436 4.57902148 0.51547330

  State 5
               mean       var      prop
mixt.  1  1.6930449 2.8175781 0.1582646
mixt.  2 -0.4497420 4.6599348 0.2189699
mixt.  3 -0.4184269 0.5722242 0.2198830
mixt.  4  0.4486712 4.2258270 0.4028825

> print(hm_model$HMM$distribution$mean)
[[1]]
[1]  1.660939  4.316445 -1.303234 -1.831079

[[2]]
[1]   2.806775  -4.777410 -11.513074  -8.218117

[[3]]
[1]  2.361224 -5.378609  1.073019  2.945220

[[4]]
[1] -0.92275326 -0.01946494 -2.17184476 -3.00404436

[[5]]
[1]  1.6930449 -0.4497420 -0.4184269  0.4486712

> #print(hm_model$HMM$distribution$mean[, seq(1, ncol(hm_model$HMM$distribution$mean), by = 2)])
> print(unlist(hm_model$HMM$distribution$mean))
 [1]   1.66093853   4.31644487  -1.30323407  -1.83107941   2.80677517
 [6]  -4.77740980 -11.51307396  -8.21811689   2.36122371  -5.37860919
[11]   1.07301931   2.94521973  -0.92275326  -0.01946494  -2.17184476
[16]  -3.00404436   1.69304486  -0.44974196  -0.41842689   0.44867117
> #print(unlist(hm_model$HMM$distribution$mean[1,]))
> #print(matrix(unlist(hm_model$HMM$distribution$mean[1,])))
> #print(matrix(unlist(hm_model$HMM$distribution$proportion[1,])))
> 
> # predict 
> #sum(hm_model$HMM$transMat[last(VitPath$states),] * .colSums((matrix(unlist(hm_model$HMM$distribution$mean[1,]), nrow=4,ncol=5)) * (matrix(unlist(hm_model$HMM$distribution$proportion[1,]), nrow=4,ncol=5)), m=4,n=5))
> change <- sum(hm_model$HMM$transMat[last(VitPath$states),] * .colSums((matrix(unlist(hm_model$HMM$distribution$mean), nrow=4,ncol=5)) * (matrix(unlist(hm_model$HMM$distribution$proportion), nrow=4,ncol=5)), m=4,n=5))
> print(change)
[1] -0.7696849
> print(tail(AAPL_Subset$AAPL.Close))
           AAPL.Close
2013-02-22     450.81
2013-02-25     442.80
2013-02-26     448.97
2013-02-27     444.57
2013-02-28     441.40
2013-03-01     430.47
> pred <- (tail(AAPL_Subset$AAPL.Close) + change)
> print(pred)
           AAPL.Close
2013-02-22   450.0403
2013-02-25   442.0303
2013-02-26   448.2003
2013-02-27   443.8003
2013-02-28   440.6303
2013-03-01   429.7003
> 
> actual <- head(testset$AAPL.Close)
> print(actual)
           AAPL.Close
2013-03-04     420.05
2013-03-05     431.14
2013-03-06     425.66
2013-03-07     430.58
2013-03-08     431.72
2013-03-11     437.87
> 
> # MAPE = sum(|pred - actual|/|actual|)*100/n
> #MAPE <- pred$AAPL.Close - actual$AAPL.Close
> #MAPE <- abs((pred$AAPL.Close - actual$AAPL.Close)/actual$AAPL.Close)
> MAPE <- abs((pred$AAPL.Close - 420.05)/420.05) * 100
> print(MAPE)
           AAPL.Close
2013-02-22   7.139701
2013-02-25   5.232785
2013-02-26   6.701658
2013-02-27   5.654164
2013-02-28   4.899492
2013-03-01   2.297421
> 
> # single HMM
> #sum(hm_model$HMM$transMat[last(VitPath$states),] * .colSums((matrix(unlist(hm_model$HMM$distribution$mean), nrow=1,ncol=5)) * (matrix(unlist(hm_model$HMM$distribution$proportion), nrow=1,ncol=5)), m=1,n=5))
> 
> #chartSeries(testset, theme="white")
> #chartSeries(test, theme="white")
> 
> # Forward-backward 
> fb <- forwardBackward(hm_model, test, FALSE)
> #print(fb)
> #print(AAPL_Subset[,4] - AAPL_Predict [,1])
> 
> #layout(matrix(1:2, nrow=2))
> #layout(matrix(2:1, ncol=2))
> layout(1:2)
> print(matrix(2:1, ncol=2))
     [,1] [,2]
[1,]    2    1
> 
> # show the states with predicted closing value
> chartSeries(pred)
> #chartSeries(AAPL_Predict[,1], #theme="white.mono", 
> #chartSeries(AAPL_Predict[,1], layout = layout(matrix(2:1)), # 1, 2, byrow = TRUE), #respect = TRUE), #theme="white.mono", 
> #TA="addTA(AAPL_Predict[AAPL_Predict[,2]==1,1], legend = \"one day?\", on=1, col=5,pch=25);
> #addTA(AAPL_Predict[AAPL_Predict[,2]==2,1],on=1,type='p',col=6,pch=24);
> #addTA(AAPL_Predict[AAPL_Predict[,2]==3,1],on=1,type='p',col=7,pch=23);
> #addTA(AAPL_Predict[AAPL_Predict[,2]==4,1],on=1,type='p',col=8,pch=22);
> #addTA(AAPL_Predict[AAPL_Predict[,2]==5,1],on=1,type='p',col=10,pch=21)
> #")
> 
> #addTA(AAPL_Predict[AAPL_Predict[,2]==1,1],on=1,type="p",col=5,pch=25)
> #addTA(AAPL_Predict[AAPL_Predict[,2]==2,1],on=1,type="p",col=6,pch=24)
> #addTA(AAPL_Predict[AAPL_Predict[,2]==3,1],on=1,type="p",col=7,pch=23)
> #addTA(AAPL_Predict[AAPL_Predict[,2]==4,1],on=1,type="p",col=8,pch=22)
> #addTA(AAPL_Predict[AAPL_Predict[,2]==5,1],on=1,type="p",col=10,pch=21)
> 
> 
> proc.time()
   user  system elapsed 
  4.331   0.059   4.672 
