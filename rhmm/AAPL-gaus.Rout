
R version 3.0.2 (2013-09-25) -- "Frisbee Sailing"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> library(quantmod)
Loading required package: Defaults
Loading required package: xts
Loading required package: zoo

Attaching package: ‘zoo’

The following objects are masked from ‘package:base’:

    as.Date, as.Date.numeric

Loading required package: TTR
Version 0.4-0 included new data defaults. See ?getSymbols.
> 
> require(devEMF)
Loading required package: devEMF
> #postscript('AAPL-gaus.eps')
> 
> getSymbols("AAPL")
    As of 0.4-0, ‘getSymbols’ uses env=parent.frame() and
 auto.assign=TRUE by default.

 This  behavior  will be  phased out in 0.5-0  when the call  will
 default to use auto.assign=FALSE. getOption("getSymbols.env") and 
 getOptions("getSymbols.auto.assign") are now checked for alternate defaults

 This message is shown once per session and may be disabled by setting 
 options("getSymbols.warning4.0"=FALSE). See ?getSymbol for more details
[1] "AAPL"
> chartSeries(AAPL, theme="white")
> trainset <- window(AAPL, start = as.Date("2000-01-01"), end = as.Date("2013-03-01"))
> #AAPL_Subset <- window(AAPL, start = as.Date("2000-01-01"), end = as.Date("2013-03-01"))
> #AAPL_Train <- cbind(AAPL_Subset$AAPL.Close - AAPL_Subset$AAPL.Open, AAPL_Subset$AAPL.Volume)
> train <- cbind(trainset$AAPL.Close - trainset$AAPL.Open)
> #AAPL_Train <- cbind(AAPL_Subset$AAPL.Close - AAPL_Subset$AAPL.Open)
> #print(AAPL_Train)
> 
> testset <- window(AAPL, start = as.Date("2013-03-01"), end = as.Date("2014-03-01"))
> test <- cbind(testset$AAPL.Close - testset$AAPL.Open)
> 
> library(RHmm)
Loading required package: MASS
Loading required package: nlme
> # Baum-Welch Algorithm to find the model for the given observations
> #hm_model <- HMMFit(obs = AAPL_Train, nStates = 5)
> hm_model <- HMMFit(obs = AAPL_Train, nStates = 5, nMixt = 4, dis = "MIXTURE")
> 
> # Viterbi Algorithm to find the most probable state sequence
> VitPath <- viterbi (hm_model, AAPL_Train)
> 
> # scatter plot
> postscript('AAPL-gaus.eps')
> AAPL_Predict <- cbind(trainset$AAPL.Close, VitPath$states)
> #AAPL_Predict <- cbind(AAPL_Subset$AAPL.Close, VitPath$states)
> #print(AAPL_Subset[,4] - AAPL_Predict [,1])
> 
> # predict next stock value m = nMixt, n = nStates
> #sum(a[last(v),] * .colSums((matrix(unlist(a), nrow=4,ncol=5)) * (matrix(unlist(a), nrow=4,ncol=5)), m=4,n=5))
> # gaussian mixture HMM: nrow = nMixture, ncol = nStates
> print(hm_model$HMM$transMat[last(VitPath$states),])
[1]  9.898334e-01 3.638020e-256  1.016662e-02  0.000000e+00  0.000000e+00
> print(hm_model$HMM$distribution)

Model:
5 states HMM with mixture of 4 1-d gaussian distributions

Distribution parameters:
  State 1
                mean          var       prop
mixt.  1 -18.6777390   0.09513677 0.02056970
mixt.  2 -11.7813192   0.23451443 0.06468754
mixt.  3  -0.1778369 176.53375858 0.43222366
mixt.  4  -2.5852725  22.47400635 0.48251911

  State 2
               mean        var      prop
mixt.  1 -2.8213784  0.2009112 0.0432078
mixt.  2 -2.4358813 10.5501915 0.2598780
mixt.  3  0.3678798 15.5865038 0.2742788
mixt.  4  1.2825068  4.1377685 0.4226354

  State 3
               mean      var      prop
mixt.  1 -0.4621214 24.44578 0.1820756
mixt.  2 -3.3282170 31.06484 0.1942951
mixt.  3 -2.9581812 31.22710 0.2004992
mixt.  4  3.0633185 28.38735 0.4231302

  State 4
                 mean       var       prop
mixt.  1 -3.244477353 1.0653185 0.09829426
mixt.  2  1.956786237 2.9918364 0.18398594
mixt.  3  2.365860782 2.8884906 0.18801652
mixt.  4  0.005681295 0.3646579 0.52970328

  State 5
              mean       var       prop
mixt.  1 -1.890829 1.5535834 0.06315052
mixt.  2 -1.871704 0.8061880 0.16472743
mixt.  3 -1.140005 0.2217269 0.34931055
mixt.  4  1.802938 0.8803653 0.42281151

> print(hm_model$HMM$distribution$mean)
[[1]]
[1] -18.6777390 -11.7813192  -0.1778369  -2.5852725

[[2]]
[1] -2.8213784 -2.4358813  0.3678798  1.2825068

[[3]]
[1] -0.4621214 -3.3282170 -2.9581812  3.0633185

[[4]]
[1] -3.244477353  1.956786237  2.365860782  0.005681295

[[5]]
[1] -1.890829 -1.871704 -1.140005  1.802938

> #print(hm_model$HMM$distribution$mean[, seq(1, ncol(hm_model$HMM$distribution$mean), by = 2)])
> print(unlist(hm_model$HMM$distribution$mean))
 [1] -18.677739009 -11.781319210  -0.177836948  -2.585272486  -2.821378437
 [6]  -2.435881298   0.367879815   1.282506817  -0.462121401  -3.328216990
[11]  -2.958181158   3.063318518  -3.244477353   1.956786237   2.365860782
[16]   0.005681295  -1.890829296  -1.871704016  -1.140005484   1.802938248
> #print(unlist(hm_model$HMM$distribution$mean[1,]))
> #print(matrix(unlist(hm_model$HMM$distribution$mean[1,])))
> #print(matrix(unlist(hm_model$HMM$distribution$proportion[1,])))
> 
> testopen <- testset$AAPL.Open
> for (i in 0: length(testopen) - 1) {
+ 	testrow <- testopen[i, ]
+ #	print(testrow)
+ 	#print(testset$AAPL.Open[i, ])
+ }
> 
> # predict 
> change <- sum(hm_model$HMM$transMat[last(VitPath$states),] * .colSums((matrix(unlist(hm_model$HMM$distribution$mean), nrow=4,ncol=5)) * (matrix(unlist(hm_model$HMM$distribution$proportion), nrow=4,ncol=5)), m=4,n=5))
> #sum(hm_model$HMM$transMat[last(VitPath$states),] * .colSums((matrix(unlist(hm_model$HMM$distribution$mean[1,]), nrow=4,ncol=5)) * (matrix(unlist(hm_model$HMM$distribution$proportion[1,]), nrow=4,ncol=5)), m=4,n=5))
> print(change)
[1] -2.445773
> #print(tail(AAPL_Subset$AAPL.Close))
> head5 <- head(testset$AAPL.Close)
> print(head5)
           AAPL.Close
2013-03-01     430.47
2013-03-04     420.05
2013-03-05     431.14
2013-03-06     425.66
2013-03-07     430.58
2013-03-08     431.72
> pred <- head5 + change
> #pred <- (tail(AAPL_Subset$AAPL.Close) + change)
> print(pred)
           AAPL.Close
2013-03-01   428.0242
2013-03-04   417.6042
2013-03-05   428.6942
2013-03-06   423.2142
2013-03-07   428.1342
2013-03-08   429.2742
> 
> #actual <- head(testset$AAPL.Close)
> actual <- head(testset$AAPL.Open)
> print(actual)
           AAPL.Open
2013-03-01    438.00
2013-03-04    427.80
2013-03-05    421.48
2013-03-06    434.51
2013-03-07    424.50
2013-03-08    429.80
> 
> # MAPE = sum(|pred - actual|/|actual|)*100/n
> #MAPE <- pred$AAPL.Close - actual$AAPL.Close
> #MAPE <- abs((pred$AAPL.Close - actual$AAPL.Close)/actual$AAPL.Close)
> MAPE <- abs((pred$AAPL.Close - 420.05)/420.05) * 100
> print(MAPE)
           AAPL.Close
2013-03-01  1.8983995
2013-03-04  0.5822575
2013-03-05  2.0579044
2013-03-06  0.7532978
2013-03-07  1.9245869
2013-03-08  2.1959832
> 
> # single HMM
> #sum(hm_model$HMM$transMat[last(VitPath$states),] * .colSums((matrix(unlist(hm_model$HMM$distribution$mean), nrow=1,ncol=5)) * (matrix(unlist(hm_model$HMM$distribution$proportion), nrow=1,ncol=5)), m=1,n=5))
> 
> #chartSeries(testset, theme="white")
> #chartSeries(test, theme="white")
> 
> # Forward-backward 
> fb <- forwardBackward(hm_model, test, FALSE)
> #print(fb)
> #print(AAPL_Subset[,4] - AAPL_Predict [,1])
> 
> #layout(matrix(1:2, nrow=2))
> #layout(matrix(2:1, ncol=2))
> layout(1:2)
> print(matrix(2:1, ncol=2))
     [,1] [,2]
[1,]    2    1
> 
> # show the states with predicted closing value
> #chartSeries(pred)
> chartSeries(pred, TA = "addTA(actual, on = 1)")
> #chartSeries(pred, TA = "addTA(pred - change, on = 1)")
> 
> #chartSeries(AAPL_Predict[,1], #theme="white.mono", 
> #chartSeries(AAPL_Predict[,1], layout = layout(matrix(2:1)), # 1, 2, byrow = TRUE), #respect = TRUE), #theme="white.mono", 
> #TA="addTA(AAPL_Predict[AAPL_Predict[,2]==1,1], legend = \"one day?\", on=1, col=5,pch=25);
> #addTA(AAPL_Predict[AAPL_Predict[,2]==2,1],on=1,type='p',col=6,pch=24);
> #addTA(AAPL_Predict[AAPL_Predict[,2]==3,1],on=1,type='p',col=7,pch=23);
> #addTA(AAPL_Predict[AAPL_Predict[,2]==4,1],on=1,type='p',col=8,pch=22);
> #addTA(AAPL_Predict[AAPL_Predict[,2]==5,1],on=1,type='p',col=10,pch=21)
> #")
> 
> 
> proc.time()
   user  system elapsed 
  4.956   0.060   5.190 
